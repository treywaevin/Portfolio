{"version":3,"file":"static/js/4265.488e099d.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/updater-out-modes/browser/BounceOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/Utils.js","../node_modules/@tsparticles/updater-out-modes/browser/DestroyOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/NoneOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/OutOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/OutOfCanvasUpdater.js"],"sourcesContent":["import { calculateBounds, } from \"@tsparticles/engine\";\nimport { bounceHorizontal, bounceVertical } from \"./Utils.js\";\nexport class BounceOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\n            \"bounce\",\n            \"split\",\n        ];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        let handled = false;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta, direction);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (handled) {\n            return;\n        }\n        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = calculateBounds(pos, size), canvasSize = container.canvas.size;\n        bounceHorizontal({ particle, outMode, direction, bounds, canvasSize, offset, size });\n        bounceVertical({ particle, outMode, direction, bounds, canvasSize, offset, size });\n    }\n}\n","import { getRangeValue } from \"@tsparticles/engine\";\nconst minVelocity = 0, boundsMin = 0;\nexport function bounceHorizontal(data) {\n    if ((data.outMode !== \"bounce\" && data.outMode !== \"split\") ||\n        (data.direction !== \"left\" && data.direction !== \"right\")) {\n        return;\n    }\n    if (data.bounds.right < boundsMin && data.direction === \"left\") {\n        data.particle.position.x = data.size + data.offset.x;\n    }\n    else if (data.bounds.left > data.canvasSize.width && data.direction === \"right\") {\n        data.particle.position.x = data.canvasSize.width - data.size - data.offset.x;\n    }\n    const velocity = data.particle.velocity.x;\n    let bounced = false;\n    if ((data.direction === \"right\" &&\n        data.bounds.right >= data.canvasSize.width &&\n        velocity > minVelocity) ||\n        (data.direction === \"left\" && data.bounds.left <= boundsMin && velocity < minVelocity)) {\n        const newVelocity = getRangeValue(data.particle.options.bounce.horizontal.value);\n        data.particle.velocity.x *= -newVelocity;\n        bounced = true;\n    }\n    if (!bounced) {\n        return;\n    }\n    const minPos = data.offset.x + data.size;\n    if (data.bounds.right >= data.canvasSize.width && data.direction === \"right\") {\n        data.particle.position.x = data.canvasSize.width - minPos;\n    }\n    else if (data.bounds.left <= boundsMin && data.direction === \"left\") {\n        data.particle.position.x = minPos;\n    }\n    if (data.outMode === \"split\") {\n        data.particle.destroy();\n    }\n}\nexport function bounceVertical(data) {\n    if ((data.outMode !== \"bounce\" && data.outMode !== \"split\") ||\n        (data.direction !== \"bottom\" && data.direction !== \"top\")) {\n        return;\n    }\n    if (data.bounds.bottom < boundsMin && data.direction === \"top\") {\n        data.particle.position.y = data.size + data.offset.y;\n    }\n    else if (data.bounds.top > data.canvasSize.height && data.direction === \"bottom\") {\n        data.particle.position.y = data.canvasSize.height - data.size - data.offset.y;\n    }\n    const velocity = data.particle.velocity.y;\n    let bounced = false;\n    if ((data.direction === \"bottom\" &&\n        data.bounds.bottom >= data.canvasSize.height &&\n        velocity > minVelocity) ||\n        (data.direction === \"top\" && data.bounds.top <= boundsMin && velocity < minVelocity)) {\n        const newVelocity = getRangeValue(data.particle.options.bounce.vertical.value);\n        data.particle.velocity.y *= -newVelocity;\n        bounced = true;\n    }\n    if (!bounced) {\n        return;\n    }\n    const minPos = data.offset.y + data.size;\n    if (data.bounds.bottom >= data.canvasSize.height && data.direction === \"bottom\") {\n        data.particle.position.y = data.canvasSize.height - minPos;\n    }\n    else if (data.bounds.top <= boundsMin && data.direction === \"top\") {\n        data.particle.position.y = minPos;\n    }\n    if (data.outMode === \"split\") {\n        data.particle.destroy();\n    }\n}\n","import { Vector, getDistances, isPointInside, } from \"@tsparticles/engine\";\nconst minVelocity = 0;\nexport class DestroyOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"destroy\"];\n    }\n    update(particle, direction, _delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"normal\":\n            case \"outside\":\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                break;\n            case \"inside\": {\n                const { dx, dy } = getDistances(particle.position, particle.moveCenter), { x: vx, y: vy } = particle.velocity;\n                if ((vx < minVelocity && dx > particle.moveCenter.radius) ||\n                    (vy < minVelocity && dy > particle.moveCenter.radius) ||\n                    (vx >= minVelocity && dx < -particle.moveCenter.radius) ||\n                    (vy >= minVelocity && dy < -particle.moveCenter.radius)) {\n                    return;\n                }\n                break;\n            }\n        }\n        container.particles.remove(particle, undefined, true);\n    }\n}\n","import { Vector, isPointInside, } from \"@tsparticles/engine\";\nconst minVelocity = 0;\nexport class NoneOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"none\"];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        if ((particle.options.move.distance.horizontal &&\n            (direction === \"left\" || direction === \"right\")) ??\n            (particle.options.move.distance.vertical &&\n                (direction === \"top\" || direction === \"bottom\"))) {\n            return;\n        }\n        const gravityOptions = particle.options.move.gravity, container = this.container, canvasSize = container.canvas.size, pRadius = particle.getRadius();\n        if (!gravityOptions.enable) {\n            if ((particle.velocity.y > minVelocity && particle.position.y <= canvasSize.height + pRadius) ||\n                (particle.velocity.y < minVelocity && particle.position.y >= -pRadius) ||\n                (particle.velocity.x > minVelocity && particle.position.x <= canvasSize.width + pRadius) ||\n                (particle.velocity.x < minVelocity && particle.position.x >= -pRadius)) {\n                return;\n            }\n            if (!isPointInside(particle.position, container.canvas.size, Vector.origin, pRadius, direction)) {\n                container.particles.remove(particle);\n            }\n        }\n        else {\n            const position = particle.position;\n            if ((!gravityOptions.inverse &&\n                position.y > canvasSize.height + pRadius &&\n                direction === \"bottom\") ||\n                (gravityOptions.inverse && position.y < -pRadius && direction === \"top\")) {\n                container.particles.remove(particle);\n            }\n        }\n    }\n}\n","import { Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange, } from \"@tsparticles/engine\";\nconst minVelocity = 0, minDistance = 0;\nexport class OutOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"out\"];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"inside\": {\n                const { x: vx, y: vy } = particle.velocity;\n                const circVec = Vector.origin;\n                circVec.length = particle.moveCenter.radius;\n                circVec.angle = particle.velocity.angle + Math.PI;\n                circVec.addTo(Vector.create(particle.moveCenter));\n                const { dx, dy } = getDistances(particle.position, circVec);\n                if ((vx <= minVelocity && dx >= minDistance) ||\n                    (vy <= minVelocity && dy >= minDistance) ||\n                    (vx >= minVelocity && dx <= minDistance) ||\n                    (vy >= minVelocity && dy <= minDistance)) {\n                    return;\n                }\n                particle.position.x = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.width,\n                }));\n                particle.position.y = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.height,\n                }));\n                const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);\n                particle.direction = Math.atan2(-newDy, -newDx);\n                particle.velocity.angle = particle.direction;\n                break;\n            }\n            default: {\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                switch (particle.outType) {\n                    case \"outside\": {\n                        particle.position.x =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.x;\n                        particle.position.y =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.y;\n                        const { dx, dy } = getDistances(particle.position, particle.moveCenter);\n                        if (particle.moveCenter.radius) {\n                            particle.direction = Math.atan2(dy, dx);\n                            particle.velocity.angle = particle.direction;\n                        }\n                        break;\n                    }\n                    case \"normal\": {\n                        const warp = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {\n                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                            left: -particle.getRadius() - particle.offset.x,\n                            right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                            top: -particle.getRadius() - particle.offset.y,\n                        }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);\n                        if (direction === \"right\" &&\n                            nextBounds.left > canvasSize.width + particle.offset.x) {\n                            particle.position.x = newPos.left;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!warp) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\n                            particle.position.x = newPos.right;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!warp) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        if (direction === \"bottom\" &&\n                            nextBounds.top > canvasSize.height + particle.offset.y) {\n                            if (!warp) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.top;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\n                            if (!warp) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.bottom;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n}\n","import { BounceOutMode } from \"./BounceOutMode.js\";\nimport { DestroyOutMode } from \"./DestroyOutMode.js\";\nimport { NoneOutMode } from \"./NoneOutMode.js\";\nimport { OutOutMode } from \"./OutOutMode.js\";\nconst checkOutMode = (outModes, outMode) => {\n    return (outModes.default === outMode ||\n        outModes.bottom === outMode ||\n        outModes.left === outMode ||\n        outModes.right === outMode ||\n        outModes.top === outMode);\n};\nexport class OutOfCanvasUpdater {\n    constructor(container) {\n        this._updateOutMode = (particle, delta, outMode, direction) => {\n            for (const updater of this.updaters) {\n                updater.update(particle, direction, delta, outMode);\n            }\n        };\n        this.container = container;\n        this.updaters = [];\n    }\n    init(particle) {\n        this.updaters = [];\n        const outModes = particle.options.move.outModes;\n        if (checkOutMode(outModes, \"bounce\")) {\n            this.updaters.push(new BounceOutMode(this.container));\n        }\n        else if (checkOutMode(outModes, \"out\")) {\n            this.updaters.push(new OutOutMode(this.container));\n        }\n        else if (checkOutMode(outModes, \"destroy\")) {\n            this.updaters.push(new DestroyOutMode(this.container));\n        }\n        else if (checkOutMode(outModes, \"none\")) {\n            this.updaters.push(new NoneOutMode(this.container));\n        }\n    }\n    isEnabled(particle) {\n        return !particle.destroyed && !particle.spawning;\n    }\n    update(particle, delta) {\n        const outModes = particle.options.move.outModes;\n        this._updateOutMode(particle, delta, outModes.bottom ?? outModes.default, \"bottom\");\n        this._updateOutMode(particle, delta, outModes.left ?? outModes.default, \"left\");\n        this._updateOutMode(particle, delta, outModes.right ?? outModes.default, \"right\");\n        this._updateOutMode(particle, delta, outModes.top ?? outModes.default, \"top\");\n    }\n}\n"],"names":["BounceOutMode","constructor","container","this","modes","update","particle","direction","delta","outMode","includes","handled","plugin","plugins","undefined","particleBounce","pos","getPosition","offset","size","getRadius","bounds","calculateBounds","canvasSize","canvas","data","right","position","x","left","width","velocity","bounced","newVelocity","getRangeValue","options","bounce","horizontal","value","minPos","destroy","bounceHorizontal","bottom","y","top","height","vertical","bounceVertical","DestroyOutMode","_delta","outType","isPointInside","Vector","origin","dx","dy","getDistances","moveCenter","vx","vy","radius","particles","remove","NoneOutMode","move","distance","gravityOptions","gravity","pRadius","enable","inverse","OutOutMode","circVec","length","angle","Math","PI","addTo","create","floor","randomInRange","min","max","newDx","newDy","atan2","warp","newPos","sizeValue","nextBounds","initialPosition","getRandom","checkOutMode","outModes","default","OutOfCanvasUpdater","_updateOutMode","updater","updaters","init","push","isEnabled","destroyed","spawning"],"sourceRoot":""}